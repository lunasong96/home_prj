package day0623;
/**
쉬프트 연산자( 비트밀기 연산 )
<<   : (left shift) - 비트를 왼쪽으로 밀고, 밀어서 빈칸을 항상 0으로 채운다.
>>   : (right shift) - 비트를 오른쪽으로 밀고, 밀어 빈칸을 최상위 부호비트에 양수면 0을 음수면 1을 채운다.
>>> : (unsigned right shift) - 비트를 오른쪽으로 밀고, 밀어서 빈칸을 항상 0으로 채운다.
         (음수를 표현하지 않는 우 시프트)

*/
class Operator4 
{
	public static void main(String[] args) 
	{
		int i = 6; 
		/*
		6 // 0000 0000 0000 0000 0000 0000 0000 0110
        48  // 0000 0000 0000 0000 0000 0000 0011 0000
		*/
		System.out.println(i + " << 3 = " + (i << 3)); //48
		i = 33;
		/*
		33 // 0000 0000 0000 0000 0000 0000 0010 0001
		8	// 0000 0000 0000 0000 0000 0000 0000 1000
		*/
		System.out.println(i + " >> 2 = " + (i >> 2)); //8
		i = 128;
		/*
		128 // 0000 0000 0000 0000 0000 0000 1000 0000
		16   // 0000 0000 0000 0000 0000 0000 0001 0000
		*/
		System.out.println(i + " >>> 3 = " + (i >>> 3)); //16

		i = -1;
		/*
		-1 // 1111 1111 1111 1111 1111 1111 1111 1111
		16   // 0111 1111 1111 1111 1111 1111 1111 1111
		*/
		System.out.println(i + " >>> 3 = " + (i >>> 1)); //약 21억

		//left shift : 최대로 밀릴 수 있는 칸 수(31칸)를 초과하면 다시 뒤로 돌아온다. (즉, 32칸은 원상복귀)
		i = 1;
		System.out.println(i + " << 31 = " + (i << 31));
		// 0000 0000 0000 0000 0000 0000 0000 0000
		// 1000 0000 0000 0000 0000 0000 0000 0000

		System.out.println(i + " << 31 = " + (i << 32));
		// 0000 0000 0000 0000 0000 0000 0000 0000
		// 0000 0000 0000 0000 0000 0000 0000 0001


	}
}
